/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import type { Program } from "@metaplex-foundation/umi";

import { ProgramError } from "@metaplex-foundation/umi";

type ProgramErrorConstructor = new (program: Program, cause?: Error) => ProgramError;
const codeToErrorMap = new Map<number, ProgramErrorConstructor>();
const nameToErrorMap = new Map<string, ProgramErrorConstructor>();

/** InvalidBps: Invalid basis points value */
export class InvalidBpsError extends ProgramError {
  override readonly name: string = "InvalidBps";

  readonly code: number = 0x0; // 0

  constructor(program: Program, cause?: Error) {
    super("Invalid basis points value", program, cause);
  }
}
codeToErrorMap.set(0x0, InvalidBpsError);
nameToErrorMap.set("InvalidBps", InvalidBpsError);

/** CloseTimestampInPast: Close timestamp is in the past */
export class CloseTimestampInPastError extends ProgramError {
  override readonly name: string = "CloseTimestampInPast";

  readonly code: number = 0x1; // 1

  constructor(program: Program, cause?: Error) {
    super("Close timestamp is in the past", program, cause);
  }
}
codeToErrorMap.set(0x1, CloseTimestampInPastError);
nameToErrorMap.set("CloseTimestampInPast", CloseTimestampInPastError);

/** ResolveTimestampBeforeClose: Resolve timestamp is before the close timestamp */
export class ResolveTimestampBeforeCloseError extends ProgramError {
  override readonly name: string = "ResolveTimestampBeforeClose";

  readonly code: number = 0x2; // 2

  constructor(program: Program, cause?: Error) {
    super("Resolve timestamp is before the close timestamp", program, cause);
  }
}
codeToErrorMap.set(0x2, ResolveTimestampBeforeCloseError);
nameToErrorMap.set("ResolveTimestampBeforeClose", ResolveTimestampBeforeCloseError);

/** MarketClosed: Market is closed */
export class MarketClosedError extends ProgramError {
  override readonly name: string = "MarketClosed";

  readonly code: number = 0x3; // 3

  constructor(program: Program, cause?: Error) {
    super("Market is closed", program, cause);
  }
}
codeToErrorMap.set(0x3, MarketClosedError);
nameToErrorMap.set("MarketClosed", MarketClosedError);

/** MarketInvalid: Market is invalid */
export class MarketInvalidError extends ProgramError {
  override readonly name: string = "MarketInvalid";

  readonly code: number = 0x4; // 4

  constructor(program: Program, cause?: Error) {
    super("Market is invalid", program, cause);
  }
}
codeToErrorMap.set(0x4, MarketInvalidError);
nameToErrorMap.set("MarketInvalid", MarketInvalidError);

/** MarketNotResolved: Market is not resolved */
export class MarketNotResolvedError extends ProgramError {
  override readonly name: string = "MarketNotResolved";

  readonly code: number = 0x5; // 5

  constructor(program: Program, cause?: Error) {
    super("Market is not resolved", program, cause);
  }
}
codeToErrorMap.set(0x5, MarketNotResolvedError);
nameToErrorMap.set("MarketNotResolved", MarketNotResolvedError);

/** MarketNotInvalid: Market is not invalid */
export class MarketNotInvalidError extends ProgramError {
  override readonly name: string = "MarketNotInvalid";

  readonly code: number = 0x6; // 6

  constructor(program: Program, cause?: Error) {
    super("Market is not invalid", program, cause);
  }
}
codeToErrorMap.set(0x6, MarketNotInvalidError);
nameToErrorMap.set("MarketNotInvalid", MarketNotInvalidError);

/** AlreadyResolved: Market already resolved */
export class AlreadyResolvedError extends ProgramError {
  override readonly name: string = "AlreadyResolved";

  readonly code: number = 0x7; // 7

  constructor(program: Program, cause?: Error) {
    super("Market already resolved", program, cause);
  }
}
codeToErrorMap.set(0x7, AlreadyResolvedError);
nameToErrorMap.set("AlreadyResolved", AlreadyResolvedError);

/** AlreadyClaimed: Already claimed */
export class AlreadyClaimedError extends ProgramError {
  override readonly name: string = "AlreadyClaimed";

  readonly code: number = 0x8; // 8

  constructor(program: Program, cause?: Error) {
    super("Already claimed", program, cause);
  }
}
codeToErrorMap.set(0x8, AlreadyClaimedError);
nameToErrorMap.set("AlreadyClaimed", AlreadyClaimedError);

/** ResolveTooEarly: Market resolution timestamp has not been reached */
export class ResolveTooEarlyError extends ProgramError {
  override readonly name: string = "ResolveTooEarly";

  readonly code: number = 0x9; // 9

  constructor(program: Program, cause?: Error) {
    super("Market resolution timestamp has not been reached", program, cause);
  }
}
codeToErrorMap.set(0x9, ResolveTooEarlyError);
nameToErrorMap.set("ResolveTooEarly", ResolveTooEarlyError);

/** InvalidOption: Invalid option for market */
export class InvalidOptionError extends ProgramError {
  override readonly name: string = "InvalidOption";

  readonly code: number = 0xa; // 10

  constructor(program: Program, cause?: Error) {
    super("Invalid option for market", program, cause);
  }
}
codeToErrorMap.set(0xa, InvalidOptionError);
nameToErrorMap.set("InvalidOption", InvalidOptionError);

/** MarketMintMismatch: Mint address does not match market mint */
export class MarketMintMismatchError extends ProgramError {
  override readonly name: string = "MarketMintMismatch";

  readonly code: number = 0xb; // 11

  constructor(program: Program, cause?: Error) {
    super("Mint address does not match market mint", program, cause);
  }
}
codeToErrorMap.set(0xb, MarketMintMismatchError);
nameToErrorMap.set("MarketMintMismatch", MarketMintMismatchError);

/** MarketResolverMismatch: Resolver address does not match market resolver */
export class MarketResolverMismatchError extends ProgramError {
  override readonly name: string = "MarketResolverMismatch";

  readonly code: number = 0xc; // 12

  constructor(program: Program, cause?: Error) {
    super("Resolver address does not match market resolver", program, cause);
  }
}
codeToErrorMap.set(0xc, MarketResolverMismatchError);
nameToErrorMap.set("MarketResolverMismatch", MarketResolverMismatchError);

/** UserWalletMismatch: Wallet address does not match user wallet */
export class UserWalletMismatchError extends ProgramError {
  override readonly name: string = "UserWalletMismatch";

  readonly code: number = 0xd; // 13

  constructor(program: Program, cause?: Error) {
    super("Wallet address does not match user wallet", program, cause);
  }
}
codeToErrorMap.set(0xd, UserWalletMismatchError);
nameToErrorMap.set("UserWalletMismatch", UserWalletMismatchError);

/** ConfigAuthorityMismatch: Authority address does not match config authority */
export class ConfigAuthorityMismatchError extends ProgramError {
  override readonly name: string = "ConfigAuthorityMismatch";

  readonly code: number = 0xe; // 14

  constructor(program: Program, cause?: Error) {
    super("Authority address does not match config authority", program, cause);
  }
}
codeToErrorMap.set(0xe, ConfigAuthorityMismatchError);
nameToErrorMap.set("ConfigAuthorityMismatch", ConfigAuthorityMismatchError);

/** InactiveTooEarly: Market inactive timestamp has not been reached */
export class InactiveTooEarlyError extends ProgramError {
  override readonly name: string = "InactiveTooEarly";

  readonly code: number = 0xf; // 15

  constructor(program: Program, cause?: Error) {
    super("Market inactive timestamp has not been reached", program, cause);
  }
}
codeToErrorMap.set(0xf, InactiveTooEarlyError);
nameToErrorMap.set("InactiveTooEarly", InactiveTooEarlyError);

/** DeserializationError: Failed to deserialize account */
export class DeserializationErrorError extends ProgramError {
  override readonly name: string = "DeserializationError";

  readonly code: number = 0x10; // 16

  constructor(program: Program, cause?: Error) {
    super("Failed to deserialize account", program, cause);
  }
}
codeToErrorMap.set(0x10, DeserializationErrorError);
nameToErrorMap.set("DeserializationError", DeserializationErrorError);

/** SerializationError: Failed to serialize account */
export class SerializationErrorError extends ProgramError {
  override readonly name: string = "SerializationError";

  readonly code: number = 0x11; // 17

  constructor(program: Program, cause?: Error) {
    super("Failed to serialize account", program, cause);
  }
}
codeToErrorMap.set(0x11, SerializationErrorError);
nameToErrorMap.set("SerializationError", SerializationErrorError);

/** FeeOverflow: Combined platform and creator fees exceed 100% */
export class FeeOverflowError extends ProgramError {
  override readonly name: string = "FeeOverflow";

  readonly code: number = 0x12; // 18

  constructor(program: Program, cause?: Error) {
    super("Combined platform and creator fees exceed 100%", program, cause);
  }
}
codeToErrorMap.set(0x12, FeeOverflowError);
nameToErrorMap.set("FeeOverflow", FeeOverflowError);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getHplParimutuelErrorFromCode(
  code: number,
  program: Program,
  cause?: Error,
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getHplParimutuelErrorFromName(
  name: string,
  program: Program,
  cause?: Error,
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
